<?php

declare(strict_types=1);

namespace Ziumper\MultiClassMap;

use RuntimeException;

class AutoloadSpliter {
    
    private string $classmapFile;
    private string $staticFile;
    
    public function __construct(private string $vendorDir) {
        $this->classmapFile = $this->vendorDir . '/composer/autoload_classmap.php';
        $this->staticFile = $this->vendorDir . '/composer/autoload_static.php';
    }
    
    public function getClassMapParts(): array 
    {
        return $this->getParts($this->classmapFile);
    }
    
    /**
     * 
     * We are taking the path without vendor to redo 
     * a install map, it may change how composer auto-load is doing 
     * things in future, this way we just do our thing 
     * 
     * @param string $file
     * @return array
     */
    private function getParts(string $file) {
        if (!file_exists($file)) {
            return [];
        }

        $classmap = include $file;

        $parts = [];
        
        foreach ($classmap as $class => $path) {
            $pathWithoutVendor = str_replace($this->vendorDir, '', $path);
            
            //gets the first prefix of the class name after first '\' sign
            $prefix = explode('\\', $class, 2)[0] ?: 'global';
            $parts[$prefix][$class] = $pathWithoutVendor;
        }
            
        return $parts;
    }
    
    
    public function getStaticParts(): array 
    {
        return $this->getParts($this->staticFile);
    }
    
    
    //TODO Composer\Autoload\AutoLoadGenerator - reuse it for my own generation of auto load class map files
    public function split(): void
    {
        $parts = $this->getClassMapParts();        
        $generatedPartName = [];

        //save the specifc files into seperated class map files
        foreach ($parts as $name => $map) {
            $partContent = <<< PHP
            <?php 
            // autoload_classmap_{$name}.php part @generated by MultiClassMapPlugin (aggregates per-prefix parts)

            \$vendorDir = dirname(dirname(__FILE__));
            \$baseDir = dirname(\$vendorDir);
                    
            return array(
            
            PHP;
            
            foreach($map as $className => $path) {
                $classNameWithDoubleBackwardSlash = str_replace("\\","\\\\",$className);
                $partContent .= <<<PHP
                    "$classNameWithDoubleBackwardSlash" => \$vendorDir . "$path",
                        
                PHP;
            }
            
       
            //end the file partial adds closing and new line
            $partContent .= ");\n";
            $fileName = $this->vendorDir . "/composer/autoload_classmap_{$name}.php";
            $generatedPartName[] = $name;
            file_put_contents(
                filename: $fileName,
                data: $partContent
            );
        }
        
        sort($generatedPartName);

        //prepare autoload splitted 
        $autoloadContent = <<<PHP
        <?php
        // autoload_classmap.php @generated by MultiClassMapPlugin (aggregates per-prefix parts)

        \$vendorDir = dirname(dirname(__FILE__));
        \$baseDir = dirname(\$vendorDir);

        \$map = [];

        \$parts = array(

        PHP;
        
        foreach($generatedPartName as $fileName) {
            $autoloadContent .= <<<PHP
            \$vendorDir . '/composer/autoload_classmap_$fileName.php',
                    
            PHP;
        }
        
        $autoloadContent .= ");\n\n";
        
        $autoloadContent .= <<<PHP
        foreach (\$parts as \$file) {
            // include each partial array
            \$part = include \$file;
            if (is_array(\$part)) {
                \$map += \$part;
            }
        }

        return \$map;
        PHP; 
        
        unlink($this->classmapFile);
        
        file_put_contents(
            filename: $this->classmapFile, 
            data: $autoloadContent
        );
        
      
        //Removal of array classmap
        $code = file_get_contents($this->staticFile);        
        $pattern = '/public\s+static\s+\$classMap\s*=\s*(array\s*\(|\[)/i';
        if (!preg_match($pattern, $code, $m, PREG_OFFSET_CAPTURE)) {
            throw new RuntimeException("Not found 'public static \$classMap' inside file.");
        }

        $token = $m[1][0];
        $tokenOffset = $m[1][1];

        $openChar = ($token[0] === '[') ? '[' : '(';
        $openPos = strpos($code, $openChar, $tokenOffset);
        if ($openPos === false) {
            throw new RuntimeException("No array initatior.");
        }
        
        $closePos = $this->findMatchingClosing($code, $openPos);
        if ($closePos === null) {
            throw new RuntimeException("No array closing char.");
        }

        $afterClosePos = $closePos + 1;
        $semicolonPos = strpos($code, ';', $afterClosePos);
        if ($semicolonPos === false) {
            throw new RuntimeException("No semicolon at the end.");
        }
        
        $newCode = substr($code, 0, $openPos-6). "array();" . substr($code, $semicolonPos + 1);

        $regexp = '/\$loader->classMap\s*=[^;]+;/';
        if (preg_match($regexp, $newCode, $matches, PREG_OFFSET_CAPTURE)) {
            $startPos = $matches[0][1];
            $endPos = $startPos + strlen($matches[0][0]) - 1; 
        } else {
           throw new RuntimeException("No loader classmap found");
        }
        
        $newCode = str_replace($matches[0][0],"\$loader->classMap = include __DIR__ . '/autoload_classmap.php';" ,$newCode);
        if (file_put_contents($this->staticFile, $newCode) === false) {
            throw new RuntimeException("Saving the file has failed: $this->staticFile");
        }
    }
    
    
    private function findMatchingClosing(string $code, int $openPos): ?int {
        $len = strlen($code);
        $pos = $openPos;
        $depth = 0;
        $inSingle = false;
        $inDouble = false;
        $escape = false;

        for (; $pos < $len; $pos++) {
            $ch = $code[$pos];

            if ($escape) { $escape = false; continue; }
            if ($ch === '\\') { $escape = true; continue; }

            if ($inSingle) {
                if ($ch === "'") $inSingle = false;
                continue;
            }
            if ($inDouble) {
                if ($ch === '"') $inDouble = false;
                continue;
            }
            if ($ch === "'") { $inSingle = true; continue; }
            if ($ch === '"') { $inDouble = true; continue; }

            if ($ch === '(' || $ch === '[') { $depth++; continue; }
            if ($ch === ')' || $ch === ']') {
                $depth--;
                if ($depth === 0) return $pos;
            }
        }

        return null;
    }
}
